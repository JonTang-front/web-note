### 内存分配
- 32位操作系统给V8执行引擎分配的内存空间是700Mb；
- 64位操作系统给V8执行引擎分配的内存空间是1.4Gb

### 内存回收
JS的内存回收机制：标记清除 和 引用计数
> 引用计数：跟踪记录每个值被引用的次数。增加一个对象引用时，引用次数+1，释放一个引用时，引用次数-1。最终垃圾回收机制会回收那些引用次数为0的对象。但是引用计数算法有一个致命的问题：循环引用。如果两个对象出现相互引用，引用次数永远不会变成0，也就是内存永远不会被回收。为了解决循环引用造成的问题，现代浏览器都通过使用标记清除算法来实现垃圾回收。

算法流程：
1. JS全局保存一个引用计数对象，当一个对象（变量，函数等）被创建时，会在引用计数对象里添加一个该引用次数的标记；
2. 对象被引用增加一次，相应的标记+1；
3. 对象被引用减少一次，相应的标记-1，直至变成0；
4. 最后垃圾回收机制遍历引用计数对象，回收那些引用标记次数为0的对象内存空间

> 标记清除：从算法根部（root，在JS中就是全局对象）出发，定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，垃圾回收机制进行内存收回

算法流程：
1. 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记；
2. 从根部出发将能触及到的对象的标记清除；
3. 那些还存在标记的变量被视为准备删除的变量；
4. 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间

### 内存泄漏
##### 引起浏览器内存泄漏的情况：
1. 滥用全局变量，因为全局变量在整个程序执行期间都不会回收。解决办法：使用严格模式避免 或者 在全局变量使用完成后设置为null/undefined；
2. 闭包使用不当，闭包可以维持外部函数的执行环境，使其内存不被回收。解决办法：在函数退出之前，把不使用的局部函数全部删除；
3. DOM引用未删除，特别是子元素引用被全局缓存，即使元素被删除，元素引用以及元素的父元素依然会保存在内存中不会被回收； 
4. 定时器没有clear

##### 引起浏览器内存溢出的情况：
1. 全局缓存不设置size，比如用于全局缓存的数组不设置大小。解决办法：添加全局缓存数组size判断，模拟队列（先进先出，unshift）缓存数据
2. 操作大文件，比如上传超过1G的大文件时，会出现内存不够而奔溃。解决办法：应该对大文件进行切片，做断点续传；
